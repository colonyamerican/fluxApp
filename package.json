{
  "name": "fluxapp",
  "version": "0.1.0",
  "description": "A isomorphic flux app design implementation",
  "main": "lib/index.js",
  "scripts": {
    "test": "mocha test/server && ./node_modules/karma/bin/karma start",
    "doc": "node_modules/doxx/bin/doxx --source lib --target docs"
  },
  "keywords": [
    "isomorphic",
    "flux"
  ],
  "author": {
    "name": "Jason Brumwell"
  },
  "license": "MIT",
  "dependencies": {
    "bluebird": "^2.9.8",
    "fluxapp-router": "^1.0.6",
    "iso-fetch": "^0.4.2",
    "lodash": "^2.4.1",
    "path-match": "^1.2.2",
    "path-to-regexp": "^1.0.1"
  },
  "devDependencies": {
    "chai": "^1.10.0",
    "doxx": "^1.2.5",
    "esprima-fb": "^8001.2001.0-dev-harmony-fb",
    "jscs": "^1.9.0",
    "jscs-jsdoc": "^0.4.0",
    "json-loader": "^0.5.1",
    "jsx-loader": "^0.12.1",
    "karma": "^0.12.24",
    "karma-chrome-launcher": "^0.1.5",
    "karma-mocha": "^0.1.9",
    "karma-sinon-chai": "^0.2.0",
    "karma-sourcemap-loader": "^0.3.0",
    "karma-spec-reporter": "0.0.16",
    "karma-webpack": "^1.3.1",
    "mocha": "^2.0.1",
    "null-loader": "^0.1.0",
    "react": "^0.13.2",
    "sinon": "^1.12.1",
    "webpack": "^1.4.13",
    "webpack-dev-server": "^1.6.5"
  },
  "readme": "# Flux based Architecture\n\nThis module is an effort to ease the development of [flux](http://www.github.com/facebook/flux) based isomorphic applications.\n\n### Install\n\n`npm install fluxapp --save`\n\n### Stores\n\n#### Action Binding\n\nfluxApp stores can bind to actions that are dispatched, the example below will call `onUserLogin`\non a successful user.login action\n\n```\n  var fluxApp = require('fluxapp');\n\n  fluxApp.createStore('namespace', {\n    mixins: [fluxApp.mixins.component],\n\n    actions: {\n      onUserLogin: 'user.login'\n    },\n\n    onUserLogin: function(result, actionType) {\n      // process data from the user.login event\n    }\n  });\n```\n\nOne store function can bind to multiple actions. In the following example\n`onUserStateChange` is called both when user logs in and out\n\n```\n  ...\n  actions: {\n    onUserStateChange: ['user.login', 'user.logout']\n  },\n\n  onUserStateChange: function(result, actionType) {\n  ...\n\n```\n\n### Actions\n\nActions are namespaced and allow for both async and sync actions. Sync actions only dispatch their\naction event, whereas async functions will dispatch both a before and after event.\n\nSync actions emit sync events, async events emit a sync before event, main action event\nwhen the promise resolves and an after event afterwards.\n\nIf a failure is thrown, a failed event is emitted async/sync depending on the state of the promise\n\n```\n  var fluxApp = require('fluxapp');\n\n  fluxApp.createActions('namespace', {\n    sync: function() {\n        return 'sync';\n    },\n\n    syncFailure: function() {\n        throw new Error('sync failure');\n    },\n\n    async: function() {\n        return new Promise(function(resolve) {\n          setImmediate(function() {\n              resolve('async');\n          });\n        });\n    },\n\n    asyncFailure: function() {\n      return new Promise(function(resolve, reject) {\n        setImmediate(function() {\n            reject(new Error('async'));\n        });\n      });\n    }\n  });\n\n  var actions = fluxApp.getActions('namespace');\n\n  actions.sync();\n```\n\n#### Binding to side events\n\nIt's possible to easily bind to before/after/failed events from inside the stores, consider the following:\n\n```\n  var fluxApp = require('fluxapp');\n\n  fluxApp.createStore('namespace', {\n    mixins: [fluxApp.mixins.component],\n\n    actions: {\n      onFailedLogin: 'user.login:failed',\n      onBeforeLogin: 'user.login:before'\n    },\n\n    onFailedLogin: function(result, actionType) {\n      // Called when login fails\n    },\n\n    onBeforeLogin: function(result, actionType) {\n      // Called before executing the login action\n    }\n  });\n```\n\n\n\n### Component Mixin\n\nThe mixin component automatically binds to stores change events and will listen for async action events\nlike before, after or failed so the ui can be updated accordingly. It also takes care of ensuring that\nthe component is currently mounted.\n\nThe mixin will also expose a few helper methods `getStore(namespace)`, `getActions(namespace)`, `getAction(namespace, method)`\n\n```\nReact.createClass({\n  mixins: [fluxApp.mixins.component],\n\n  getInitalState: function() {\n    return {\n      test: this.getStore('test').state,\n      anothertest: this.getStore('anothertest').state\n    };\n  },\n\n  flux: {\n    stores: {\n      onTestUpdate: 'test'\n    },\n\n    actions: {\n      onTestMethodBefore: 'test.method:before'\n    }\n  },\n\n  onTestMethodBefore: function() {\n    // fired before test.method event, if the event is async\n  },\n\n  onTestUpdate: function() {\n    // fired if the test store is changed\n  },\n\n  onClick: function() {\n    var actions = this.getActions('test'); // could also use this.getAction('test', 'method')\n\n    actions.method('arg1', 'arg2');\n  },\n\n  render: function() {\n    return (\n      <h1>Hello Flux</h1>\n    );\n  }\n});\n```\n\n### Isomorphic applications\n\n#### Server side\n\nOur suggested approach to creating an isomorphic application is:\n- Load the component that we have determined is required for this route.\n- Expose a static load method that invokes the actions needed to populate the stores.\n\n```\nvar fluxApp = require('fluxapp');\n\nfluxApp.createRoutes(require('./client/routes'));\n\nfunction handler(req, reply) {\n\n  var componentClass = fluxApp.matchRoute(req.path, {\n    method: req.method\n  });\n  var Component = react.createFactory(componentClass);\n  var data = normalizeRequestData(req);\n\n  componentClass.load(data).then(function() {\n    var componentHtml = react.renderToString(Component());\n    var state = {\n        method: req.method,\n        payload: fluxApp.dehydrate()\n    };\n\n    // .. Inject componentHtml and state json into your layout ..\n  });\n}\n```\n\n#### Client side\n\n```\n$(function() {\n  var fluxApp = require('fluxapp');\n\n  fluxApp.createRoutes(require('./routes'));\n\n  var component = fluxApp.matchRoute(window.location.pathname, {\n    method: statePassedFromServer.method\n  });\n\n  fluxApp.rehydrate(statePassedFromServer.payload);\n\n  // ... bind component to node on page representing the component ...\n});\n```\n\n#### Component load method\n\nIf the component depends on data from any store, its `statics.load` method should return a promise\nthat evaluates to an object that's going to be an initial state of application stores.\n\n```\nReact.createClass({\n  mixins: [fluxApp.mixins.component],\n\n  statics : {\n    load : function(request) {\n      var userData = fluxApp.getActions('user').getData();\n      var item = fluxApp.getActions('item').getDetails({\n        itemId: request.params.itemId\n      });\n\n      return Promise.props({\n        user: userData,\n        item: item\n      });\n    }\n  }\n});\n```\n\n### Helper methods\n\n`fluxApp.getDispatcher`: return an instance of the flux dispatcher\n`fluxApp.getRouter`: return an instance of the router\n`fluxApp.getActionType(string)` converts namespaced strings ie: user.login:after to constants USER_LOGIN_AFTER\n",
  "readmeFilename": "README.md"
}
